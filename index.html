<!doctype html>
<!-- Single-file procedural WebGL art with sliders.
   Save as index.html and open in a browser. -->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>noise</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="favicon.svg" type="image/svg+xml" />
  <style>
    :root{--ui-h:36px;--gap:8px;--bg:#0b0b0b}
    html,body{height:100%;margin:0;background:var(--bg);color:#ddd;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    #wrap{display:grid;grid-template-rows:1fr var(--ui-h);height:100vh}
    canvas{width:100%;height:100%;display:block}
    .controls{display:flex;gap:var(--gap);align-items:center;padding:6px;background:linear-gradient(0deg,rgba(255,255,255,0.02),transparent);backdrop-filter:blur(6px)}
    .ctrl{display:flex;align-items:center;gap:6px;color:#ddd;font-size:13px}
    label{min-width:86px}
    input[type=range]{width:160px}
    .seedBtn{padding:6px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:#ddd;cursor:pointer}
    .small{font-size:12px;color:#aaa}
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="gl"></canvas>

    <div class="controls">
      <div class="ctrl">
        <label>Scale</label>
        <input id="scale" type="range" min="0.2" max="6" step="0.01" value="1.6">
      </div>

      <div class="ctrl">
        <label>Speed</label>
        <input id="speed" type="range" min="0" max="3" step="0.01" value="0.9">
      </div>

      <div class="ctrl">
        <label>Detail</label>
        <input id="detail" type="range" min="1" max="8" step="1" value="4">
      </div>

      <div class="ctrl">
        <label>Hue</label>
        <input id="hue" type="range" min="0" max="1" step="0.001" value="0.14">
      </div>

      <div class="ctrl">
        <button id="seed" class="seedBtn">New Seed</button>
      </div>  
    </div>
  </div>

<script>
"use strict";

/* Minimal WebGL fragment-shader art.
   Uniforms controlled: u_time, u_res, u_scale, u_speed, u_detail, u_hue, u_seed, u_mouse.
   Simple signed-distance-noise-like flow built with rotated periodic functions.
*/

const canvas = document.getElementById("gl");
const gl = canvas.getContext("webgl", { antialias: true }) || canvas.getContext("experimental-webgl");
if (!gl) throw new Error("WebGL not available");

function compile(type, src){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
    throw new Error("Shader compile failed");
  }
  return s;
}

const vert = `
attribute vec2 a_pos;
void main(){ gl_Position = vec4(a_pos,0.0,1.0); }
`;

const frag = `
precision highp float;
uniform vec2 u_res;
uniform float u_time;
uniform float u_scale;
uniform float u_speed;
uniform float u_detail;
uniform float u_hue;
uniform float u_seed;
uniform vec2 u_mouse;

#define PI 3.141592653589793
// 2D rotation
mat2 rot(float a){ float c=cos(a), s=sin(a); return mat2(c,-s,s,c); }

// pseudo-random
float hash(vec2 p){
  p = fract(p*vec2(123.34,456.21)+u_seed);
  p += dot(p, p+45.32);
  return fract(p.x*p.y);
}

// smooth noise-ish
float noise(vec2 p){
  vec2 i = floor(p);
  vec2 f = fract(p);
  float a = hash(i);
  float b = hash(i + vec2(1.0,0.0));
  float c = hash(i + vec2(0.0,1.0));
  float d = hash(i + vec2(1.0,1.0));
  vec2 u = f*f*(3.0-2.0*f);
  return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y;
}

// fractal flow
float fbm(vec2 p){
  float v = 0.0;
  float amp = 0.5;
  float freq = 1.0;
  for(int i=0;i<8;i++){
    if(float(i)>=u_detail) break;
    v += amp * noise(p * freq);
    p = p*1.9 + vec2(1.7,9.2);
    amp *= 0.5;
    freq *= 1.9;
  }
  return v;
}

vec3 hsv(float h, float s, float v){
  vec3 c = clamp(abs(mod(h*6.0 + vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0,1.0);
  return v * mix(vec3(1.0), c, s);
}

void main(){
  vec2 uv = (gl_FragCoord.xy / u_res) - 0.5;
  uv.x *= u_res.x / u_res.y;
  vec2 m = (u_mouse / u_res) - 0.5;
  m.x *= u_res.x / u_res.y;

  float t = u_time * u_speed;
  float scale = u_scale;
  vec2 p = uv * scale;
  p += m * 0.5;

  // swirling warp
  float a = fbm(p + vec2(cos(t*0.2), sin(t*0.15))*0.8);
  p += 0.6 * vec2(sin(a*PI*2.0 + t*0.3), cos(a*PI*2.0 - t*0.2));

  // layered bands
  float v = 0.0;
  float accum = 0.0;
  float w = 1.0;
  for(int i=0;i<6;i++){
    if(float(i) >= u_detail) break;
    float layer = fbm(p * (1.0 + float(i)*0.7) + float(i)*12.3);
    v += (sin((p.x + p.y)*0.7 + layer*3.0 + t*0.6 + float(i)*1.3) * 0.5 + 0.5) * w;
    accum += w;
    w *= 0.6;
    p *= rot(0.7);
  }
  v /= max(0.0001, accum);

  // contrast and color
  float contrast = smoothstep(0.12, 0.88, v);
  float hue = u_hue + 0.2 * sin(t*0.2 + u_seed*6.28);
  vec3 col = hsv(hue + contrast*0.2, 0.85, 0.9*pow(contrast, 1.1));

  // add soft glow
  float glow = v * 0.9;
  col += vec3(glow*0.3, glow*0.2, glow*0.5);

  gl_FragColor = vec4(col, 1.0);
}
`;

// compile program
const vs = compile(gl.VERTEX_SHADER, vert);
const fs = compile(gl.FRAGMENT_SHADER, frag);
const prog = gl.createProgram();
gl.attachShader(prog, vs);
gl.attachShader(prog, fs);
gl.linkProgram(prog);
if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
gl.useProgram(prog);

// quad
const pos = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, pos, gl.STATIC_DRAW);
const a_pos = gl.getAttribLocation(prog, "a_pos");
gl.enableVertexAttribArray(a_pos);
gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

// uniforms
const U = {
  res: gl.getUniformLocation(prog, "u_res"),
  time: gl.getUniformLocation(prog, "u_time"),
  scale: gl.getUniformLocation(prog, "u_scale"),
  speed: gl.getUniformLocation(prog, "u_speed"),
  detail: gl.getUniformLocation(prog, "u_detail"),
  hue: gl.getUniformLocation(prog, "u_hue"),
  seed: gl.getUniformLocation(prog, "u_seed"),
  mouse: gl.getUniformLocation(prog, "u_mouse")
};

// set GL state
gl.disable(gl.DEPTH_TEST);

// UI bindings
const sliders = {
  scale: document.getElementById("scale"),
  speed: document.getElementById("speed"),
  detail: document.getElementById("detail"),
  hue: document.getElementById("hue"),
  seedBtn: document.getElementById("seed")
};

let seed = Math.random();
let mouse = [0,0];
let start = performance.now();
let raf = null;

function resize(){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const w = Math.floor(canvas.clientWidth * dpr);
  const h = Math.floor(canvas.clientHeight * dpr);
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w;
    canvas.height = h;
    gl.viewport(0,0,w,h);
  }
  gl.uniform2f(U.res, w, h);
}
window.addEventListener("resize", resize);
resize();

function setUniforms(time){
  gl.uniform1f(U.time, time);
  gl.uniform1f(U.scale, parseFloat(sliders.scale.value));
  gl.uniform1f(U.speed, parseFloat(sliders.speed.value));
  gl.uniform1f(U.detail, parseFloat(sliders.detail.value));
  gl.uniform1f(U.hue, parseFloat(sliders.hue.value));
  gl.uniform1f(U.seed, seed);
  gl.uniform2f(U.mouse, mouse[0], mouse[1]);
}

function render(t){
  const time = (t - start) / 1000;
  setUniforms(time);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  raf = requestAnimationFrame(render);
}

raf = requestAnimationFrame(render);

// interaction
canvas.addEventListener("pointermove", e => {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width);
  const y = (rect.height - (e.clientY - rect.top)) * (canvas.height / rect.height); // flip y to shader coords
  mouse = [x, y];
});

canvas.addEventListener("pointerdown", e => {
  // small jump in seed for tactile change
  seed = Math.random();
});

sliders.seedBtn.addEventListener("click", () => {
  seed = Math.random();
});

// keyboard quick tweaks (no focus needed)
window.addEventListener("keydown", (e) => {
  if (e.key === " "){ seed = Math.random(); e.preventDefault(); } // space changes seed
  if (e.key === "ArrowUp") sliders.scale.value = Math.min(parseFloat(sliders.scale.max), parseFloat(sliders.scale.value) + 0.1);
  if (e.key === "ArrowDown") sliders.scale.value = Math.max(parseFloat(sliders.scale.min), parseFloat(sliders.scale.value) - 0.1);
});

// optional: simple fallback if WebGL not present handled at top by throwing

// expose minimal controls for direct manipulation in console
window._ART = {
  setSeed(s){ seed = s },
  getSeed(){ return seed },
  set(param, v){ if(sliders[param]) sliders[param].value = v }
};
</script>
</body>
</html>
